package main

import (
	"fmt"
	"log"
)

const g_unknown_text = "<UNKNOWN>"

func getTimeAsText(time float64) string {
	// HH:MM:SS:MS
	hh := (int(time) / (1000 * 60 * 60)) % 24
	mm := (int(time) / (1000 * 60)) % 60
	ss := (int(time) / 1000) % 60
	ms := int(time) % 1000
	return fmt.Sprintf("%02d:%02d:%02d:%03d", hh, mm, ss, ms)
}

func getHeader(bpm uint64, channel uint64, notes_count uint64, track_length float64, track_name string, instrument_name string, track_copyright string) string {
	var outputBuffer = ""
	outputBuffer += "#----------------File Description-----------------#\n"
	outputBuffer += "# This file generated by Midi To Mikrotik Converter\n"
	outputBuffer += "# Visit app repo: https://github.com/altucor/midi-to-mikrotik-go\n"
	//outputBuffer += "# Original midi file name/path: " + m_filePath + "\n";
	outputBuffer += "# MIDI Channel: " + fmt.Sprintf("%d", channel) + "\n"
	outputBuffer += "# Track BPM: " + fmt.Sprintf("%d", bpm) + "\n"
	outputBuffer += "# Number of notes: " + fmt.Sprintf("%d", notes_count) + "\n"
	outputBuffer += "# Track length: " + getTimeAsText(track_length) + "\n"
	outputBuffer += "# Track name: " + track_name + "\n"
	outputBuffer += "# Instrument name: " + instrument_name + "\n"
	outputBuffer += "# Track copyright: " + track_copyright + "\n"
	//outputBuffer += "# Track text: " + chunk.mtrkChunkHandler.getTrackText() + "\n";
	//outputBuffer += "# Track copyright: " + chunk.mtrkChunkHandler.getCopyright() + "\n";
	//outputBuffer += "# Vocals: " + chunk.mtrkChunkHandler.getInstrumentName() + "\n";
	//outputBuffer += "# Text marker: " + chunk.mtrkChunkHandler.getTextMarker() + "\n";
	//outputBuffer += "# Cue Point: " + chunk.mtrkChunkHandler.getCuePoint() + "\n";
	outputBuffer += "#-------------------------------------------------#\n\n"
	return outputBuffer
}

func durationToMs(vlv VLV, pulses_per_second float64) float64 {
	return float64(vlv.Value) * pulses_per_second
}

func buildNote(event Event, octave_shift int, note_shift int, fine_tuning float64, pulses_per_second float64, current_time float64, comments bool) string {
	/*
	 * :beep frequency=440 length=1000ms;
	 * :delay 1000ms;
	 */
	var output string = ""
	freq_cmd, duration := getNote(event)
	freq := g_freqNotes[freq_cmd+(octave_shift*NOTES_IN_OCTAVE)+note_shift] + fine_tuning
	duration_text := fmt.Sprintf("%f", durationToMs(duration, pulses_per_second)) + "ms;"
	if event.Cmd.MainCmd == NOTE_ON {
		output += ":beep frequency=" + fmt.Sprintf("%f", freq) + " length=" + duration_text
		if comments {
			output += " # " + g_symbolicNotes[freq_cmd+(octave_shift*NOTES_IN_OCTAVE)+note_shift]
			if fine_tuning != 0 {
				output += " " + fmt.Sprintf("%+.3f", fine_tuning) + "Hz"
			}

			output += " @ " + getTimeAsText(current_time) + "\n"
		} else {
			output += "\n"
		}
	}
	if duration.Value != 0 {
		output += ":delay " + duration_text + "\n"
	}
	//fmt.Println("Note: ", g_symbolicNotes[freq_cmd], freq, durationToMs(duration, pulses_per_second))

	return output
}

func generateScript(midi MidiFile, track uint64, channel uint64, new_bpm uint64, octave_shift int, note_shift int, fine_tuning float64, comments bool) string {
	var output = ""
	// iterate through all events
	var bpm uint64 = 0
	var pulses_per_second float64 = 0.0
	var instrument_name = g_unknown_text
	var track_name = g_unknown_text
	var track_copyright = g_unknown_text

	switch midi.Mthd.Format {
	case MIDI_V0:
		// Single track file
		break
	case MIDI_V1:
		// First track contains only service info and should be skipped
		if new_bpm != 0 {
			bpm = new_bpm
		} else {
			tempo_event := midi.Tracks[0].findEventByCmd(MidiEventCodeFromByte(TEMPO))
			bpm = getEventTempo(tempo_event)
		}
		fmt.Println("BPM:", bpm)
		pulses_per_second = (60000.0 / (float64(bpm) * float64(midi.Mthd.Ppqn)))
		instrument_name = getTextFromEvent(midi.Tracks[track].findEventByCmd(MidiEventCodeFromByte(INSTRUMENT_NAME)))
		track_name = getTextFromEvent(midi.Tracks[track].findEventByCmd(MidiEventCodeFromByte(TRACK_NAME)))
		track_copyright = getTextFromEvent(midi.Tracks[track].findEventByCmd(MidiEventCodeFromByte(COPYRIGHT)))
	case MIDI_V2:
		// At current moment dont know how to behave correctly
		break
	default:
		log.Fatal("Unknown midi format detected: ", midi.Mthd.Format)
	}

	fmt.Println("Pulses per second: ", pulses_per_second)
	var body string = ""
	var track_length float64 = durationToMs(midi.Tracks[track].Predelay, pulses_per_second)
	var note_on uint64 = 0
	var note_off uint64 = 0
	for i := 0; i < len(midi.Tracks[track].Events); i++ {
		event := midi.Tracks[track].Events[i]
		if event.Cmd.MainCmd == NOTE_ON || event.Cmd.MainCmd == NOTE_OFF {
			if event.Cmd.MainCmd == NOTE_ON {
				note_on++
			} else if event.Cmd.MainCmd == NOTE_OFF {
				note_off++
			}
			temp := buildNote(event, octave_shift, note_shift, fine_tuning, pulses_per_second, track_length, comments)
			//fmt.Println(temp)
			body += temp
		}
		track_length += durationToMs(midi.Tracks[track].Events[i].Delay, pulses_per_second)
	}
	if note_on != note_off {
		log.Fatal("Error not equal count of events: note_on = ", note_on, " note_off = ", note_off)
	}
	//fmt.Println("Notes count: ", note_on)
	//fmt.Println("Track length: ", track_length, "ms")
	//fmt.Println("Time total:", getTimeAsText(track_length))

	output += getHeader(bpm, 0, note_on, track_length, track_name, instrument_name, track_copyright)
	output += body
	return output
}
